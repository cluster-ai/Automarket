 - when an api request is made but the connection breaks during read the request fails with no httpresponse error code because communications were dirupted.

 - need to give all exceptions an "out" to whatever process is running that breaks the program in a benign way so that the location of error is known and can be logged accurately in the container program.

 - program is not aware of what it needs from the handbook in order to run properly (assuming the config is inproperly configured or api does not have requested data type such as USD and BTC as asset_id_quote and asset_id_base for handbook["exchanges"] which is needed for gathering the correct type of historical data of coins)

 - if a json file exsists but does not have the right keys or format the program will break

 - check to see if database.UpdateIndex() will run into errors when run such as it trying to write to files that arn't there if called in certain spots of code. etc

 - error catching for all possabilities within database.BackfillHistoricalData() and related

 - should put handbook last update value in handbook.json not config.json

 - for api_index.json, coinAPI doesn't properly initialize it to track when the next api refresh will be or if the file does not exist it will crash.

 - when opening files, have an if statement with os.path.exists instead of a try - catch statement.

 - if the coinAPI api_index is not loaded or initialized as intended (which is possible), the api limit will default to 0 and not let any requests through.

 - for timestamps, if data from coin_api is given to us with a value other than 0 in the ten millions place (possible) it will raise an error in database.BackfillHistoricalData(). As I write this entry, we currently have that digit hard-coded as 0 right before the Z "0Z". For example, if coin_api sends 2016-02-07T09:17:00.0000004Z my program will convert it to unix and compare for validity but will output 2016-02-07T09:17:00.0000000Z since that last digit is hard-coded to 0. The program will think the data has been altered (and it was) in the unix time conversion, killing the process.

 - implement database.ReloadHistoricalIndex()